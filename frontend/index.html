<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' http://127.0.0.1:* ws://127.0.0.1:*; img-src 'self' data: file: http://127.0.0.1:*; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; media-src 'self' blob: http://127.0.0.1:*;">
  <title>ふにゃ秘書たん</title>
  <link rel="stylesheet" href="./styles.css">
  <style>
    /* 既存のスタイル */

    /* 操作モード通知 */
    .pointer-events-enabled:after {
      content: "操作モード";
      position: fixed;
      top: 10px;
      right: 10px;
      background-color: rgba(255, 0, 0, 0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 12px;
      z-index: 9999;
      pointer-events: none;
    }
  </style>
  <script>
    // グローバル設定
    const CONFIG = {
      voicevox: {
        host: 'http://127.0.0.1:50021',
        speaker_id: 8
      },
      backend: {
        host: 'http://127.0.0.1:8000',
        ws_url: 'ws://127.0.0.1:8000/ws'
      }
    };
    
    // デバッグ用フェッチラッパー
    async function debugFetch(url, options) {
      console.log(`[DEBUG] Fetch開始: ${url}`, options);
      try {
        const response = await fetch(url, options);
        console.log(`[DEBUG] Fetch完了 (${Date.now() - performance.now()}ms): ${url}`);
        return response;
      } catch (error) {
        console.log(`[DEBUG] Fetchエラー (${Date.now() - performance.now()}ms): ${url}`, error);
        throw error;
      }
    }
    
    // 既存のfetchをラップしない（renderer.jsの実装を使う）
    window.originalFetch = window.fetch;
    
    // オーバーレイ関連の設定と操作
    let currentSettings = {
      opacity: 100,
      size: 100,
      position: 'bottomRight',
      autoHide: true,
      alwaysOnTop: true
    };
    
    // オーバーレイメニューの表示/非表示を切り替え
    function toggleOverlayMenu() {
      const menu = document.getElementById('overlayMenu');
      if (menu.style.display === 'none') {
        menu.style.display = 'block';
        // メニュー表示時はマウスイベントを有効に
        if (window.electronAPI && window.electronAPI.enableMouseEvents) {
          window.electronAPI.enableMouseEvents();
        }
        // 現在の設定値をUIに反映
        loadCurrentSettings();
        
        // 設定アイコンを強調表示
        const settingsIcon = document.getElementById('settingsIcon');
        if (settingsIcon) {
          settingsIcon.style.opacity = '1';
          settingsIcon.style.transform = 'rotate(45deg)';
          settingsIcon.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        }
      } else {
        menu.style.display = 'none';
        // メニュー非表示時はマウスイベントを透過に
        if (window.electronAPI && window.electronAPI.disableMouseEvents) {
          window.electronAPI.disableMouseEvents();
        }
        
        // 設定アイコンを元に戻す
        const settingsIcon = document.getElementById('settingsIcon');
        if (settingsIcon) {
          settingsIcon.style.opacity = '0.3';
          settingsIcon.style.transform = '';
          settingsIcon.style.backgroundColor = 'rgba(0, 0, 0, 0.1)';
        }
      }
    }
    
    // 現在の設定をUIに反映
    function loadCurrentSettings() {
      // スライダーの値を設定
      document.getElementById('opacitySlider').value = currentSettings.opacity;
      document.getElementById('opacityValue').textContent = currentSettings.opacity;
      
      document.getElementById('sizeSlider').value = currentSettings.size;
      document.getElementById('sizeValue').textContent = currentSettings.size;
      
      // チェックボックスの状態を設定
      document.getElementById('autoHideToggle').checked = currentSettings.autoHide;
      document.getElementById('alwaysTopToggle').checked = currentSettings.alwaysOnTop;
    }
    
    // 透明度の更新
    function updateOpacity(value) {
      document.getElementById('opacityValue').textContent = value;
      currentSettings.opacity = parseInt(value);
      
      // 実際のスタイルに適用
      const assistantImage = document.getElementById('assistantImage');
      if (assistantImage) {
        assistantImage.style.opacity = value / 100;
      }
    }
    
    // サイズの更新
    function updateSize(value) {
      document.getElementById('sizeValue').textContent = value;
      currentSettings.size = parseInt(value);
      
      // 実際のスタイルに適用
      const assistantImage = document.getElementById('assistantImage');
      if (assistantImage) {
        assistantImage.style.transform = `scale(${value / 100})`;
      }
    }
    
    // 位置の更新
    function updatePosition(position) {
      currentSettings.position = position;
      
      const container = document.querySelector('.assistant-container');
      if (!container) return;
      
      // 位置に応じてスタイルを変更
      switch (position) {
        case 'topLeft':
          container.style.alignItems = 'flex-start';
          container.style.justifyContent = 'flex-start';
          container.style.paddingRight = '0';
          container.style.paddingLeft = '30px';
          break;
        case 'topRight':
          container.style.alignItems = 'flex-end';
          container.style.justifyContent = 'flex-start';
          container.style.paddingRight = '30px';
          container.style.paddingLeft = '0';
          break;
        case 'bottomLeft':
          container.style.alignItems = 'flex-start';
          container.style.justifyContent = 'flex-end';
          container.style.paddingRight = '0';
          container.style.paddingLeft = '30px';
          break;
        case 'bottomRight':
        default:
          container.style.alignItems = 'flex-end';
          container.style.justifyContent = 'flex-end';
          container.style.paddingRight = '30px';
          container.style.paddingLeft = '0';
          break;
      }
    }
    
    // 自動透明化の設定
    function toggleAutoHide(enabled) {
      currentSettings.autoHide = enabled;
      
      // クラス切り替えで自動透明化を制御
      if (!enabled) {
        document.body.classList.remove('mouse-active');
      }
    }
    
    // 最前面表示の切り替え
    function toggleAlwaysOnTop(enabled) {
      currentSettings.alwaysOnTop = enabled;
      
      // Electron APIを使用して設定
      if (window.electronAPI && window.electronAPI.toggleAlwaysOnTop) {
        window.electronAPI.toggleAlwaysOnTop();
      }
    }
    
    // 設定を保存
    function saveSettings() {
      if (window.electronAPI && window.electronAPI.updateSettings) {
        window.electronAPI.updateSettings({
          assistant: currentSettings
        }).then(() => {
          // 保存成功メッセージ
          console.log('設定が保存されました');
          // 簡易的な成功フィードバック
          const saveBtn = document.querySelector('.overlay-footer button');
          if (saveBtn) {
            const originalText = saveBtn.textContent;
            saveBtn.textContent = '✓ 保存完了';
            saveBtn.style.backgroundColor = '#4CAF50';
            
            setTimeout(() => {
              saveBtn.textContent = originalText;
              saveBtn.style.backgroundColor = '';
            }, 2000);
          }
        });
      }
      
      // メニューを閉じる
      toggleOverlayMenu();
    }
    
    // 吹き出しを非表示にする関数
    function hideBubble() {
      const speechBubble = document.getElementById('speechBubble');
      if (speechBubble) {
        // 吹き出しを非表示にする
        speechBubble.className = 'speech-bubble hide';
        
        // アニメーション完了まで少し待ってから完全に非表示
        setTimeout(() => {
          speechBubble.style.display = 'none';
          speechBubble.style.visibility = 'hidden';
          speechBubble.style.opacity = '0';
        }, 300);
        
        // 再生中のすべての音声を停止する
        document.querySelectorAll('audio').forEach(audio => {
          audio.pause();
          audio.currentTime = 0;
        });
        
        // 口パクアニメーションを停止（もし外部関数があれば）
        if (typeof stopTalking === 'function') {
          stopTalking();
        }
      }
    }
    
    // アプリケーションを終了する関数
    function closeApp() {
      if (window.electronAPI && window.electronAPI.closeWindow) {
        window.electronAPI.closeWindow();
      }
    }
  </script>
</head>
<body>
  <div id="app">
    <div class="assistant-container">
      <div class="speech-bubble" id="speechBubble">
        <span class="bubble-icon">💭</span>
        <span class="bubble-text" id="speechText"></span>
        <div class="bubble-close-button" id="bubbleCloseButton" onclick="hideBubble()">×</div>
      </div>
      <img id="assistantImage" class="assistant-image" src="../assets/images/secretary_normal.png" alt="秘書たん" />
      <div class="close-button" id="closeButton" onclick="closeApp()">×</div>
    </div>
    <div class="error-bubble" id="errorBubble">
      <span class="bubble-icon">⚠️</span>
      <span class="bubble-text" id="errorText"></span>
    </div>
    <div id="statusIndicator" class="status-indicator"></div>
    
    <!-- デバッグコントロール -->
    <div class="settings-icon" id="settingsIcon" onclick="toggleOverlayMenu()">⚙️</div>
    <div class="debug-controls" id="debugMenu" style="display: none;">
      <button id="normalBubbleBtn" onclick="testNormalBubble()">通常吹き出し</button>
      <button id="testBubbleBtn" onclick="testBubble()">赤吹き出し</button>
      <button id="randomLineBtn" onclick="testRandomLine()">ランダムセリフ</button>
      <button id="testZombieBtn" onclick="testZombieOverlay()">ゾンビ検出テスト</button>
      <button id="toggleClickThroughBtn" onclick="toggleClickThroughMode()">操作モード切替</button>
      <button id="devToolsBtn" onclick="openDevTools()">開発者ツール</button>
      <button id="closeMenuBtn" onclick="toggleDebugMenu()">閉じる</button>
    </div>
    
    <!-- ゲーム内オーバーレイメニュー -->
    <div class="overlay-menu" id="overlayMenu" style="display: none;">
      <div class="overlay-header">
        <span>秘書たん設定</span>
        <span class="close-btn" onclick="toggleOverlayMenu()">×</span>
      </div>
      <div class="overlay-content">
        <div class="slider-control">
          <label>透明度: <span id="opacityValue">100</span>%</label>
          <input type="range" id="opacitySlider" min="0" max="100" value="100" oninput="updateOpacity(this.value)">
        </div>
        <div class="slider-control">
          <label>サイズ: <span id="sizeValue">100</span>%</label>
          <input type="range" id="sizeSlider" min="50" max="150" value="100" oninput="updateSize(this.value)">
        </div>
        <div class="position-control">
          <label>位置:</label>
          <div class="position-buttons">
            <button onclick="updatePosition('topLeft')">左上</button>
            <button onclick="updatePosition('topRight')">右上</button>
            <button onclick="updatePosition('bottomLeft')">左下</button>
            <button onclick="updatePosition('bottomRight')">右下</button>
          </div>
        </div>
        <div class="toggle-control">
          <label>
            <input type="checkbox" id="autoHideToggle" onchange="toggleAutoHide(this.checked)">
            マウス操作時に自動で透明化
          </label>
        </div>
        <div class="toggle-control">
          <label>
            <input type="checkbox" id="alwaysTopToggle" onchange="toggleAlwaysOnTop(this.checked)">
            常に最前面に表示
          </label>
        </div>
        <div class="advanced-control">
          <label>高度な設定:</label>
          <div class="advanced-buttons">
            <button onclick="toggleDebugMenu()">開発メニュー表示</button>
            <button onclick="toggleDebugPanel()">デバッグパネル</button>
            <button onclick="openDevTools()">開発者ツール</button>
          </div>
        </div>
        <div class="overlay-footer">
          <span class="shortcut-hint">ショートカット: Ctrl+F11</span>
          <button onclick="saveSettings()">保存</button>
          <button onclick="closeApp()" class="exit-button">アプリを終了</button>
        </div>
      </div>
    </div>
  </div>

  <!-- スクリプト -->
  <script type="module" src="scripts/renderer.js"></script>
  <script>
    // AudioContextを最初のページ読み込み時に初期化
    document.addEventListener('DOMContentLoaded', () => {
      // ユーザー操作を待たずに音声を再生できるようにするための初期化
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      // サイレント音声を再生して初期化
      const silentAudio = new Audio();
      silentAudio.volume = 0.01;
      silentAudio.play().catch(err => console.log('初期サイレント再生：', err));
    });
    
    // Electron環境かどうかをチェック
    const isElectronApp = typeof window !== 'undefined' && 
                          typeof window.electronAPI !== 'undefined';
    
    console.log('環境チェック: Electron =', isElectronApp ? 'Yes' : 'No');
    
    // speak関数をグローバルに定義（renderer.jsのものがない場合のフォールバック）
    if (typeof window.speak !== 'function') {
      window.speak = function(text, emotion = 'normal', displayTime = 5000) {
        console.log(`[Fallback] 秘書たんの発言: ${text} (感情: ${emotion}, 表示時間: ${displayTime}ms)`);
        // 吹き出しを取得
        const speechBubble = document.getElementById('speechBubble');
        const speechText = document.getElementById('speechText');
        
        if (speechBubble && speechText) {
          // テキストを設定
          speechText.textContent = text;
          
          // 吹き出しを表示
          speechBubble.style.cssText = `
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
          `;
          speechBubble.className = 'speech-bubble show';
          
          // 指定時間後に非表示
          if (displayTime > 0) {
            setTimeout(() => {
              speechBubble.className = 'speech-bubble hide';
              speechBubble.style.opacity = '0';
              setTimeout(() => {
                speechBubble.style.display = 'none';
              }, 300);
            }, displayTime);
          }
        }
      };
    }
    
    // デバッグメニューの表示/非表示を切り替える
    function toggleDebugMenu() {
      const menu = document.getElementById('debugMenu');
      if (menu.style.display === 'none') {
        menu.style.display = 'flex';
      } else {
        menu.style.display = 'none';
      }
    }
    
    // 開発者ツールを開く関数
    function openDevTools() {
      if (window.electronAPI && window.electronAPI.openDevTools) {
        console.log('ElectronAPI経由で開発者ツールを開きます');
        window.electronAPI.openDevTools();
      } else {
        console.log('Electron APIが利用できないため開発者ツールを開けません');
        alert('開発者ツールを開くにはCtrl+Shift+I (Windows/Linux) または Cmd+Option+I (Mac) を押してください');
      }
    }
    
    // 通常吹き出しテスト
    function testNormalBubble() {
      console.log('通常吹き出しテスト実行');
      // 直接renderer.jsの関数を呼び出す
      window.speak('これは通常の吹き出しテストです', 'normal', 10000);
    }
    
    // 赤い吹き出しテスト（デバッグ用）
    function testBubble() {
      console.log('赤吹き出しテスト実行');
      const speechBubble = document.getElementById('speechBubble');
      const speechText = document.getElementById('speechText');
      
      // テキスト設定
      speechText.textContent = 'これはデバッグ用テストです！';
      
      // 強制的に表示（デバッグ用の赤い吹き出し）
      speechBubble.className = 'speech-bubble debug-bubble';
      speechBubble.style.cssText = `
        display: flex !important;
        visibility: visible !important;
        opacity: 1 !important;
        background-color: #ffdddd !important;
        border: 3px solid #d32f2f !important;
        position: fixed !important;
        top: 100px !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        z-index: 999999 !important;
      `;
      
      console.log('赤吹き出し設定完了');
    }
    
    // ランダムセリフをテスト実行する関数
    function testRandomLine() {
      console.log('ランダムセリフをテスト実行します');
      
      // ランダムセリフ関数が存在するか確認
      if (typeof window.initRandomLines === 'function') {
        // 既存のコントローラーを使用
        if (window.randomLinesController && typeof window.randomLinesController.showNow === 'function') {
          console.log('既存のコントローラーを使用してランダムセリフを表示します');
          window.randomLinesController.showNow();
        } else {
          // 新しいコントローラーを生成
          console.log('新しいコントローラーを生成してランダムセリフを表示します');
          const controller = window.initRandomLines(15000);
          
          // 即時実行
          if (controller && typeof controller.showNow === 'function') {
            controller.showNow();
          }
        }
      } else if (typeof window.showRandomLine === 'function') {
        // showRandomLine関数があればそれを使う
        console.log('✅ showRandomLine関数を使用してランダムセリフを有効化します');
        
        // 簡易コントローラーを作成
        window.randomLinesController = {
          showNow: window.showRandomLine,
          stop: function() { console.log('ランダムセリフを停止しました'); }
        };
      } else {
        console.error('ランダムセリフ関数が見つかりません');
        alert('ランダムセリフ機能が初期化されていません');
      }
    }
    
    // ページ読み込み完了後の処理を強化
    document.addEventListener('DOMContentLoaded', async () => {
      console.log('DOM 読み込み完了 - 初期化開始');
      
      // レンダラーの初期化を待つ
      const waitForRandomLines = () => {
        console.log('ランダムセリフ機能の初期化処理を開始');
        
        try {
          // レンダラースクリプトの読み込みを確認
          if (typeof window.initRandomLines === 'function') {
            console.log('✅ ランダムセリフ関数が見つかりました - 初期化します');
            try {
              // グローバル変数に保存
              window.randomLinesController = window.initRandomLines(15000);
              
              // テスト用に即時実行
              setTimeout(() => {
                console.log('🔍 ランダムセリフのテスト実行');
                if (window.randomLinesController && typeof window.randomLinesController.showNow === 'function') {
                  window.randomLinesController.showNow();
                }
              }, 3000);
            } catch (error) {
              console.error('ランダムセリフ初期化中にエラーが発生しました:', error);
              
              // エラー発生時に簡易コントローラーを作成
              window.randomLinesController = createFallbackController();
            }
          } else if (typeof window.showRandomLine === 'function') {
            // showRandomLine関数があればそれを使う
            console.log('✅ showRandomLine関数を使用してランダムセリフを有効化します');
            
            // 簡易コントローラーを作成
            window.randomLinesController = {
              showNow: window.showRandomLine,
              stop: function() { console.log('ランダムセリフを停止しました'); }
            };
          } else {
            console.warn('⚠️ ランダムセリフ関数がまだ見つかりません（再試行します）');
            // 再試行
            setTimeout(waitForRandomLines, 1000);
          }
        } catch (e) {
          console.error('ランダムセリフ検証中にエラーが発生しました:', e);
        }
      };
      
      // フォールバックコントローラー作成関数
      function createFallbackController() {
        console.log('フォールバックランダムセリフコントローラーを作成します');
        return {
          showNow: function() {
            const phrases = [
              "おつかれさま〜…ぎゅってしてあげたい気分なの",
              "すごいよ…ちゃんと頑張ってるの、見てるからね",
              "ふにゃ…今日はのんびりしよ？",
              "ねぇ、ちょっとだけ甘えてもいい…？",
              "ここにいるからね。ひとりじゃないよ",
              "お水飲んだ？小休憩しよっか",
              "えらいえらい…よしよしっ"
            ];
            const randomPhrase = phrases[Math.floor(Math.random() * phrases.length)];
            if (typeof window.speak === 'function') {
              window.speak(randomPhrase, 'normal', 5000);
            } else {
              console.log('フォールバック発言:', randomPhrase);
            }
          },
          stop: function() {
            console.log('フォールバックコントローラー: ランダムセリフを停止しました');
          }
        };
      }
      
      // 5秒後に初期化を開始（レンダラー初期化の時間を確保）
      setTimeout(waitForRandomLines, 5000);
    });
    
    // キーボードショートカット
    document.addEventListener('keydown', (event) => {
      // Ctrl+Shift+I または Cmd+Option+I で開発者ツールを開く
      if ((event.ctrlKey || event.metaKey) && event.shiftKey && (event.key === 'I' || event.key === 'i')) {
        openDevTools();
      }
      // F2キーでデバッグメニューの表示/非表示を切り替え
      if (event.key === 'F2') {
        toggleDebugMenu();
      }
      
      // F3キーで通常吹き出しテスト
      if (event.key === 'F3') {
        testNormalBubble();
      }
      
      // Ctrl+F11 でオーバーレイメニューを表示
      if ((event.ctrlKey || event.metaKey) && event.key === 'F11') {
        toggleOverlayMenu();
        event.preventDefault(); // デフォルトの動作を防止
      }
    });
  </script>

  <!-- デバッグパネル -->
  <div id="debug-panel" style="display: none; position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 5px; z-index: 9999999; font-family: monospace; font-size: 12px;">
    <div style="margin-bottom: 8px;">
      <button id="testZombieWarningBtn" style="background: #f44336; color: white; border: none; padding: 5px 10px; margin-right: 5px; cursor: pointer;">ゾンビ警告テスト</button>
      <button id="checkBubbleBtn" style="background: #2196f3; color: white; border: none; padding: 5px 10px; cursor: pointer;">吹き出し状態確認</button>
    </div>
    <div id="debug-info" style="max-width: 300px; max-height: 200px; overflow: auto; background: rgba(0,0,0,0.5); padding: 5px; margin-top: 5px; display: none;"></div>
  </div>

  <script>
    // デバッグモード切替時にパネルを表示/非表示
    document.addEventListener('DOMContentLoaded', () => {
      const debugPanel = document.getElementById('debug-panel');
      
      // Alt+Cのイベントはrenderer.jsで処理するため削除
      
      // ゾンビ警告テストボタン
      document.getElementById('testZombieWarningBtn').addEventListener('click', () => {
        // WebSocketのsendMessage関数が利用可能か確認
        if (typeof window.sendMessage === 'function') {
          window.sendMessage({
            type: 'zombie_warning',
            data: { count: 3 }
          });
        } else {
          console.error('sendMessage関数が見つかりません');
          window.alert('sendMessage関数が見つかりません。WebSocketハンドラーが初期化されているか確認してください。');
        }
      });
      
      // 吹き出し状態確認ボタン
      document.getElementById('checkBubbleBtn').addEventListener('click', () => {
        const bubble = document.getElementById('speechBubble');
        const debugInfo = document.getElementById('debug-info');
        
        if (bubble && debugInfo) {
          const computed = window.getComputedStyle(bubble);
          debugInfo.style.display = 'block';
          debugInfo.innerHTML = `
            <div>クラス: ${bubble.className}</div>
            <div>display: ${computed.display}</div>
            <div>visibility: ${computed.visibility}</div>
            <div>opacity: ${computed.opacity}</div>
            <div>z-index: ${computed.zIndex}</div>
            <div>position: ${computed.position}</div>
          `;
        } else {
          debugInfo.innerHTML = '吹き出し要素が見つかりません';
        }
      });
    });
  </script>

  <!-- デバッグパネルトグル関数追加 -->
  <script>
    function toggleDebugPanel() {
      const panel = document.getElementById('debug-panel');
      if (panel.style.display === 'none') {
        panel.style.display = 'block';
        const infoPanel = document.getElementById('debug-info');
        if (infoPanel) {
          infoPanel.style.display = 'block';
        }
      } else {
        panel.style.display = 'none';
      }
    }
  </script>

  <script>
    // テスト用: ゾンビオーバーレイのテスト
    function testZombieOverlay() {
      // オーバーレイマネージャーが存在するか確認
      if (window.zombieOverlayManager) {
        console.log('ゾンビオーバーレイのテストを実行します');
        window.zombieOverlayManager.testOverlay();
      } else {
        console.error('ゾンビオーバーレイマネージャーが見つかりません');
        alert('ゾンビオーバーレイマネージャーが初期化されていません');
      }
    }
  </script>
</body>
</html> 